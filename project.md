[COMMIT_EDITMSG](.\.git\COMMIT_EDITMSG) : 


[config](.\.git\config) : 


[description](.\.git\description) : 


[HEAD](.\.git\HEAD) : 


[applypatch-msg.sample](.\.git\hooks\applypatch-msg.sample) : 


[commit-msg.sample](.\.git\hooks\commit-msg.sample) : 


[fsmonitor-watchman.sample](.\.git\hooks\fsmonitor-watchman.sample) : 


[post-update.sample](.\.git\hooks\post-update.sample) : 


[pre-applypatch.sample](.\.git\hooks\pre-applypatch.sample) : 


[pre-commit.sample](.\.git\hooks\pre-commit.sample) : 


[pre-merge-commit.sample](.\.git\hooks\pre-merge-commit.sample) : 


[pre-push.sample](.\.git\hooks\pre-push.sample) : 


[pre-rebase.sample](.\.git\hooks\pre-rebase.sample) : 


[pre-receive.sample](.\.git\hooks\pre-receive.sample) : 


[prepare-commit-msg.sample](.\.git\hooks\prepare-commit-msg.sample) : 


[push-to-checkout.sample](.\.git\hooks\push-to-checkout.sample) : 


[sendemail-validate.sample](.\.git\hooks\sendemail-validate.sample) : 


[update.sample](.\.git\hooks\update.sample) : 


[index](.\.git\index) : 


[exclude](.\.git\info\exclude) : 


[HEAD](.\.git\logs\HEAD) : 


[main](.\.git\logs\refs\heads\main) : 


[main](.\.git\logs\refs\remotes\origin\main) : 


[e06aeceab3b1c5e979ca8376dcda341371b09b](.\.git\objects\01\e06aeceab3b1c5e979ca8376dcda341371b09b) : 


[dd8ddc6cbb921cefd45f6012fac04cf9f34811](.\.git\objects\0c\dd8ddc6cbb921cefd45f6012fac04cf9f34811) : 


[3fa8ef9e8e814ab294bd8df01545fc543b038d](.\.git\objects\0e\3fa8ef9e8e814ab294bd8df01545fc543b038d) : 


[43bdda51913f57d20e3fbcad46085123260d9f](.\.git\objects\0e\43bdda51913f57d20e3fbcad46085123260d9f) : 


[37e6dbbeaa96f849a67db0e64a35a3a502d2cb](.\.git\objects\0f\37e6dbbeaa96f849a67db0e64a35a3a502d2cb) : 


[f4e740f48a74f954a6a98b29e729c8ccac23b2](.\.git\objects\13\f4e740f48a74f954a6a98b29e729c8ccac23b2) : 


[c0f47b573ddf5e80a5ea128c5f90afb312dab3](.\.git\objects\22\c0f47b573ddf5e80a5ea128c5f90afb312dab3) : 


[3561eced8a0da7461cc525649d2807e9b5e741](.\.git\objects\25\3561eced8a0da7461cc525649d2807e9b5e741) : 


[560e297267e65f3616dfbe7a94f83b93408d28](.\.git\objects\27\560e297267e65f3616dfbe7a94f83b93408d28) : 


[4c731e85348b148d5058dc5fbae030332e54ef](.\.git\objects\2a\4c731e85348b148d5058dc5fbae030332e54ef) : 


[55fd6d3df611ee49467b048be222590e192721](.\.git\objects\2b\55fd6d3df611ee49467b048be222590e192721) : 


[f19010f2bda6a8f4e9f7553268398b01931844](.\.git\objects\2b\f19010f2bda6a8f4e9f7553268398b01931844) : 


[aabb3df5490b6a9ec882d85a4033214354e7bb](.\.git\objects\2d\aabb3df5490b6a9ec882d85a4033214354e7bb) : 


[09499e6dfac54b6ac4db3fbaabe402be26167f](.\.git\objects\31\09499e6dfac54b6ac4db3fbaabe402be26167f) : 


[2766671418bac7abf74dd25ea901fd320ba3b5](.\.git\objects\32\2766671418bac7abf74dd25ea901fd320ba3b5) : 


[31df0883297ac55fb2033d8f201f2ea2050bd2](.\.git\objects\35\31df0883297ac55fb2033d8f201f2ea2050bd2) : 


[6f98d417a54ae0b3cd04f9ffd3baccbec03f60](.\.git\objects\38\6f98d417a54ae0b3cd04f9ffd3baccbec03f60) : 


[51a2d45e16956d9964fe04bcc8cba86eaa1c9b](.\.git\objects\39\51a2d45e16956d9964fe04bcc8cba86eaa1c9b) : 


[3937e3fb4b2e0f29fa1c1ccdf5cfd6ade64993](.\.git\objects\3b\3937e3fb4b2e0f29fa1c1ccdf5cfd6ade64993) : 


[6e9dc0d3f85b20020c3fdc28e4888342027562](.\.git\objects\3d\6e9dc0d3f85b20020c3fdc28e4888342027562) : 


[78c30bdd75a2ac910ac643e8d5580e9d66af42](.\.git\objects\3e\78c30bdd75a2ac910ac643e8d5580e9d66af42) : 


[07a27aad91bdf6a3c38381df82553a7671b738](.\.git\objects\41\07a27aad91bdf6a3c38381df82553a7671b738) : 


[dc2d52fbfd97abc14a284f173bffedc26aedb1](.\.git\objects\42\dc2d52fbfd97abc14a284f173bffedc26aedb1) : 


[06dd5d0c1afe6aa4bff15f6470b21fa0b2ea14](.\.git\objects\47\06dd5d0c1afe6aa4bff15f6470b21fa0b2ea14) : 


[cd03e9233a801c6f447fbbcec950d4ab29741f](.\.git\objects\4e\cd03e9233a801c6f447fbbcec950d4ab29741f) : 


[66dd2c3134e62fe9bcbd18d5306180033e849a](.\.git\objects\59\66dd2c3134e62fe9bcbd18d5306180033e849a) : 


[14357fdeded4d2dfbcd4e62f9643a563f66b7d](.\.git\objects\5b\14357fdeded4d2dfbcd4e62f9643a563f66b7d) : 


[e95746b572b3691386da3836dabf5ea2cb0724](.\.git\objects\60\e95746b572b3691386da3836dabf5ea2cb0724) : 


[839c102ae3353eab435d6b746ff6f03867359c](.\.git\objects\68\839c102ae3353eab435d6b746ff6f03867359c) : 


[3bcc960962cea8c5a4f6a8a4f1a58988624aa0](.\.git\objects\6b\3bcc960962cea8c5a4f6a8a4f1a58988624aa0) : 


[feb2d88eda63e560cf5508a3a61b9c58dfa51d](.\.git\objects\6e\feb2d88eda63e560cf5508a3a61b9c58dfa51d) : 


[a15c0d2822db79f4b9a46a214e95baf897125d](.\.git\objects\6f\a15c0d2822db79f4b9a46a214e95baf897125d) : 


[54e7e0a901cc9f25afe6e01ab6fa377149d625](.\.git\objects\71\54e7e0a901cc9f25afe6e01ab6fa377149d625) : 


[eba298d6b690f3805c1df06cb64268bff505fd](.\.git\objects\73\eba298d6b690f3805c1df06cb64268bff505fd) : 


[297d638065e3e2fc0e5637ef6bffa0e2c0af15](.\.git\objects\75\297d638065e3e2fc0e5637ef6bffa0e2c0af15) : 


[3e30f7dc4c38777e5a60846867340a1a83f997](.\.git\objects\77\3e30f7dc4c38777e5a60846867340a1a83f997) : 


[5332a94cdbd11f26d08313cc09de750052d445](.\.git\objects\7c\5332a94cdbd11f26d08313cc09de750052d445) : 


[13b672b0f6cc3c82c85903dbbf437749c08c58](.\.git\objects\80\13b672b0f6cc3c82c85903dbbf437749c08c58) : 


[f4e35c6275b707444bc2918736447c2fb4c75b](.\.git\objects\81\f4e35c6275b707444bc2918736447c2fb4c75b) : 


[625e4ebb116c25ffde7608e543d089afaac561](.\.git\objects\83\625e4ebb116c25ffde7608e543d089afaac561) : 


[a6806c3c1ac4e1138cea1302042c070b66305d](.\.git\objects\8b\a6806c3c1ac4e1138cea1302042c070b66305d) : 


[acc4c2e07df2a1b513d4360bb6b514bd01ef13](.\.git\objects\8d\acc4c2e07df2a1b513d4360bb6b514bd01ef13) : 


[c7ff367d097d64b5a7f819eb7c21db709020da](.\.git\objects\8e\c7ff367d097d64b5a7f819eb7c21db709020da) : 


[fe634e3a981bfb3bfd140e722202631313ff98](.\.git\objects\8f\fe634e3a981bfb3bfd140e722202631313ff98) : 


[215fd0ca5112813318ee978f7722b6911d11c7](.\.git\objects\95\215fd0ca5112813318ee978f7722b6911d11c7) : 


[7ddc951744f5c1fcf9f5ce850188d8f339e32e](.\.git\objects\97\7ddc951744f5c1fcf9f5ce850188d8f339e32e) : 


[139b6d7bd400c4d67ca0d5ed3a5f1cb4b940b5](.\.git\objects\a2\139b6d7bd400c4d67ca0d5ed3a5f1cb4b940b5) : 


[57932133ce3b2b3ef69768ad26d9bd00b92e25](.\.git\objects\ab\57932133ce3b2b3ef69768ad26d9bd00b92e25) : 


[a1a44811ad13972b7a098b4856baaa135c2f54](.\.git\objects\ac\a1a44811ad13972b7a098b4856baaa135c2f54) : 


[f263076efb592ead506b03367643e7150f727c](.\.git\objects\af\f263076efb592ead506b03367643e7150f727c) : 


[d8dde1fec93b94b7034edc669ef926263b027e](.\.git\objects\ba\d8dde1fec93b94b7034edc669ef926263b027e) : 


[a64564f20eae94880cbc1361d3ae129c9c817c](.\.git\objects\bf\a64564f20eae94880cbc1361d3ae129c9c817c) : 


[28f2bd99e39b42ead8ae165584b7ac07ae6987](.\.git\objects\c4\28f2bd99e39b42ead8ae165584b7ac07ae6987) : 


[b44b13a5079d2d4bf0e7d4232e64bc46fc3e96](.\.git\objects\c5\b44b13a5079d2d4bf0e7d4232e64bc46fc3e96) : 


[1b0d3940a91ae83f314d47bc93d307519372be](.\.git\objects\c7\1b0d3940a91ae83f314d47bc93d307519372be) : 


[04c4ab33f74bd1a037688494f18874fbe27cac](.\.git\objects\cc\04c4ab33f74bd1a037688494f18874fbe27cac) : 


[125162d2944c7f4a162d21f91b78c6d4b14ee9](.\.git\objects\cc\125162d2944c7f4a162d21f91b78c6d4b14ee9) : 


[8848b016fb37aeb8a38370385036fdabbcfd5b](.\.git\objects\cf\8848b016fb37aeb8a38370385036fdabbcfd5b) : 


[aaeb5afee5e75dd804b5e2ec29bc50b11ca7ae](.\.git\objects\d3\aaeb5afee5e75dd804b5e2ec29bc50b11ca7ae) : 


[81e92008c68a3a1c268b90698140a000844ef9](.\.git\objects\d8\81e92008c68a3a1c268b90698140a000844ef9) : 


[1b08ac444da23499e869a6468d80ed9b446379](.\.git\objects\dc\1b08ac444da23499e869a6468d80ed9b446379) : 


[bbfbf73016d1a3efbcb401f9b7dc501374d7c2](.\.git\objects\e0\bbfbf73016d1a3efbcb401f9b7dc501374d7c2) : 


[89c77c0930b341b76c616f34f323af1e71752b](.\.git\objects\e4\89c77c0930b341b76c616f34f323af1e71752b) : 


[a6d8c4ad3c63fae3d0c38e9d41c336b9a9bdfb](.\.git\objects\e5\a6d8c4ad3c63fae3d0c38e9d41c336b9a9bdfb) : 


[9de29bb2d1d6434b8b29ae775ad8c2e48c5391](.\.git\objects\e6\9de29bb2d1d6434b8b29ae775ad8c2e48c5391) : 


[cff0b77155bff29fa44b0ce1e868a00646708d](.\.git\objects\e6\cff0b77155bff29fa44b0ce1e868a00646708d) : 


[2f7a8ed22e148378d9d39a66ed68deb55e5729](.\.git\objects\e8\2f7a8ed22e148378d9d39a66ed68deb55e5729) : 


[98b124f61da5a5d7dfcaeccf98225149914e97](.\.git\objects\e9\98b124f61da5a5d7dfcaeccf98225149914e97) : 


[3ad2eabfc5088dead8fb5feff455ba426a1bc9](.\.git\objects\ec\3ad2eabfc5088dead8fb5feff455ba426a1bc9) : 


[646d07ef71eabca19609e5e0e0e55521d627cf](.\.git\objects\ed\646d07ef71eabca19609e5e0e0e55521d627cf) : 


[e9252af62f13c91bac72eff511a6c84c76f9a4](.\.git\objects\ee\e9252af62f13c91bac72eff511a6c84c76f9a4) : 


[c33655e165323b5ad722834ead6eedade7f1da](.\.git\objects\f0\c33655e165323b5ad722834ead6eedade7f1da) : 


[00697c357a722f8487d576e62f1aee0fc59338](.\.git\objects\f2\00697c357a722f8487d576e62f1aee0fc59338) : 


[43e615f2ed7bd99f3ea077986ffd28daf23ff8](.\.git\objects\f6\43e615f2ed7bd99f3ea077986ffd28daf23ff8) : 


[e1e38ed653cc69d76bd57c379ff9dcdde634fb](.\.git\objects\f9\e1e38ed653cc69d76bd57c379ff9dcdde634fb) : 


[6af91f35a6e50b4a09032ace563a324eddf671](.\.git\objects\fb\6af91f35a6e50b4a09032ace563a324eddf671) : 


[main](.\.git\refs\heads\main) : 


[main](.\.git\refs\remotes\origin\main) : 


[.gitignore](.\.gitignore) : 


[.tags](.\.tags) : 


[.tags_sorted_by_file](.\.tags_sorted_by_file) : 


[data.json](.\config\data.json) : 


[settings.py](.\config\settings.py) : 
``````python
SETTINGS = {
    # 窗口设置
    "window_title" : "PDF 阅读器",
    "window_height": 800,
    "window_width" : 1200,

    # 插件设置
    "plugin_directory_path": "./plugins",

    # 存放数据的文件路径
    "data_path": "./config/data.json",

    # 执行周期性函数的时间间隔（单位：毫秒）
    "frequency": 500,

    # 写入/读取文本文件时的默认编码
    "encoding": "utf-8",

    # 缩放等级
    "zoom_levels": [8.33, 12.5, 18, 25, 33.33, 50, 66.67, 75, 100, 125, 150, 200, 300, 400, 600, 800, 1000, 1200, 1600, 2000, 2400, 3200, 4800, 6400],
}

``````



[__init__.py](.\config\__init__.py) : 
``````python

``````



[settings.cpython-313.pyc](.\config\__pycache__\settings.cpython-313.pyc) : 


[__init__.cpython-313.pyc](.\config\__pycache__\__init__.cpython-313.pyc) : 


[PluginManager.py](.\glueous\PluginManager.py) : 
``````python
from __future__ import annotations

import importlib.util
from pathlib import Path
from typing import Any, Dict, Iterable, List, Set, cast, TYPE_CHECKING

from glueous_plugin import Plugin
from plugins import plugin_loading_order

if TYPE_CHECKING:
    from .ReaderAccess import ReaderAccess



class PluginManager:
    """
    插件管理器，负责加载和管理插件。
    """

    def __init__(self, context: ReaderAccess):
        self.context = context

        # 存储所有加载的插件实例
        self.plugins: List[Plugin] = []

        # 插件名到插件的映射
        self.name_mapping: Dict[str, Plugin] = {}

        # 快捷键到插件的映射
        self.hotkey_mapping: Dict[str, Plugin] = {}


    def __iter__(self) -> Iterable[Plugin]:
        return iter(self.plugins)


    def __getitem__(self, key) -> Plugin | List[Plugin]:
        """
        - 若输入整数或切片，则调用 `self.plugins` 的 `__getitem__`
        - 若输入字符串，则调用 `self.name_mapping` 的 `__getitem__`
        """
        if isinstance(key, (int, slice)):
            return self.plugins[key]
        if isinstance(key, str):
            return self.name_mapping[key]
        raise TypeError(f"unsupported operand type(s) for []: '{type(key).__name__}' and '{self.__class__.__name__}'")


    def __repr__(self) -> str:
        return f"{self.__class__.__name__}()"


    def __str__(self) -> str:
        return self.__class__.__name__ + str({
            plugin.name: plugin.hotkeys
            for plugin in self.plugins
        })


    def append(self, plugin: Plugin) -> None:
        """
        添加一个插件。
        """
        self.plugins.append(plugin)
        self.name_mapping[plugin.name] = plugin
        for hotkey in plugin.hotkeys:
            self.hotkey_mapping[hotkey] = plugin


    def load_plugins_from_file(self, plugin_file: Path) -> int:
        """
        加载 `plugin_file` 文件中的所有插件， `plugin_file` 文件应为一个 .py 文件。

        “插件”类应该为 `Plugin` 类的子类。

        返回加载成功的插件数目。
        """
        if not plugin_file.is_file():
            raise FileNotFoundError(f"Plugin file not found: {plugin_file}")

        spec = importlib.util.spec_from_file_location(plugin_file.stem, plugin_file)
        if spec is None or spec.loader is None:
            raise ImportError(f"Cannot load plugin from file: {plugin_file}")

        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # 遍历模块中的所有类，找到 Plugin 的子类并实例化
        count = 0
        for attr_name in dir(module):
            attr = getattr(module, attr_name)
            if isinstance(attr, type) and issubclass(attr, Plugin) and attr is not Plugin:
                plugin_instance = attr(self.context)
                self.append(plugin_instance)
                count += 1

        return count


    def load_plugins_from_directory(self, plugin_directory: Path, recursion: bool = True) -> int:
        """
        加载 `plugin_directory` 文件夹中的所有插件， `plugin_directory` 应为一个文件夹。

        “插件”类应该为 `Plugin` 类的子类。

        若 `recursion` 为 True，则递归地加载 `plugin_directory` 的子目录中的插件。

        返回加载成功的插件数目。
        """
        if not plugin_directory.is_dir():
            raise ValueError(f"`{plugin_directory}` is not a directory.")

        count = 0

        # 使用 Path.glob 递归或非递归地查找 .py 文件
        pattern = "**/*.py" if recursion else "*.py"
        for plugin_file in plugin_directory.glob(pattern):
            if plugin_file.name.startswith("_"):  # 跳过以下划线开头的文件
                continue
            count += self.load_plugins_from_file(plugin_file)

        return count


    @staticmethod
    def _call_plugin(plugin: Plugin, method_name: str, /, *args, **kwargs) -> Any:
        """
        安全地调用插件对象 `plugin` 的某个方法 `method_name`。
        """
        try:
            return getattr(plugin, method_name)(*args, **kwargs)
        except Exception as error:
            print(f"{plugin.name}.{method_name}: {error.__class__.__name__}: {error}")
        return None


    def loaded(self) -> None:
        """
        按顺序加载所有插件。
        """
        plugin_names: Set[str] = set(self.name_mapping.keys())

        for plugin_name in plugin_loading_order:
            if plugin_name in plugin_names:
                plugin = self[plugin_name]
                if plugin.able:
                    self._call_plugin(plugin, "loaded")
                plugin_names.remove(plugin_name)

        for plugin_name in plugin_names:
            plugin = self[plugin_name]
            if plugin.able:
                self._call_plugin(plugin, "loaded")


    def run(self, hotkey: str) -> None:
        """
        根据指定的 hotkey 运行插件。
        """
        plugin = self.hotkey_mapping.get(hotkey)
        if plugin and plugin.able:
            self._call_plugin(plugin, "run")


    def unloaded(self) -> None:
        """
        卸下所有插件。
        """
        for plugin in self.plugins:
            if plugin.able:
                self._call_plugin(plugin, "unloaded")


    def bind_hotkeys(self) -> None:
        """
        绑定所有快捷键。
        """
        for hotkey in self.hotkey_mapping:
            self.context.bind_root(hotkey, lambda event, hotkey = hotkey: self.run(hotkey))

``````



[Reader.py](.\glueous\Reader.py) : 
``````python
from __future__ import annotations

from pathlib import Path
import json
import tkinter as tk
from tkinter import filedialog, messagebox, ttk, Menu
from typing import Any, Callable, Dict, List
from types import ModuleType

from .ReaderAccess  import ReaderAccess
from .PluginManager import PluginManager



def construct_menu(menu: tk.Menu, menu_structure: List[Dict[str, Any]]) -> None:
    """
    从菜单的字典结构 `menu_structure` 为菜单组件 `menu` 添加内容。

    Params:

    - `menu_structure`: 菜单的字典结构，like:

        ```python
        [
            {
                "type" : "menu",
                "label" : "文件",
                "children": [
                    {
                        "type" : "command",
                        "label" : "新建",
                        "command" : create_new,
                        "accelerator": "Ctrl+N",
                    },
                    {
                        "type" : "separator",
                    },
                    {
                        "type" : "menu",
                        "label" : "打开",
                        "children": [
                            {
                                "type" : "command",
                                "label" : "PDF 文件",
                                "command" : open_pdf,
                                "accelerator": "Ctrl+O",
                            },
                        ],
                    }
                ],
            }
        ]
        ```
    
    Return:

    - tkinter.Menu
    """

    for sublabel in menu_structure:
        if sublabel["type"] == "separator":
            menu.add_separator()
        elif sublabel["type"] == "command":
            menu.add_command(**{k: v for (k, v) in sublabel.items() if (k != "type")})
        elif sublabel["type"] == "menu":
            submenu = tk.Menu(menu, **{k: v for (k, v) in sublabel.items() if (k not in ("type", "children", "label"))})
            construct_menu(submenu, sublabel["children"]) # 递归构造子菜单项
            menu.add_cascade(label = sublabel["label"], menu=submenu)



class Reader:
    """
    主程序类，管理多标签页和全局状态。
    """

    def __init__(self, settings: Dict[str, Any]):
        self.settings: Dict[str, Any] = settings

        # 创建窗口
        self.root = tk.Tk()
        self.root.title(self.settings["window_title"])
        self.root.geometry(f"{self.settings['window_width']}x{self.settings['window_height']}")

        # 创建菜单栏
        self.menubar = tk.Menu(self.root)
        self.menu_structure: List[Dict] = []
        """
        Like:
            [
                {
                    "type"    : "menu",
                    "label"   : "example",
                    "children": [
                        {
                            "type"    : "command"
                            "label"   : "run",
                            "command" : Function,
                        }
                    ],
                }
            ]
        """
        self.update_menubar()
        self.root.config(menu = self.menubar)

        # 创建工具栏
        self.toolbar = ttk.Frame(self.root)
        self.toolbar.pack(side = tk.TOP, fill = tk.X, padx = 5, pady = 5)

        # 创建标签页容器
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        self.access = ReaderAccess(self)
        self.plugin_manager = PluginManager(self.access)
        self.plugin_manager.load_plugins_from_directory(Path(self.settings["plugin_directory_path"]))
        self.plugin_manager.bind_hotkeys()
        self.plugin_manager.loaded()

        # 加载数据文件 data.json
        # 插件可以使用 `data` 中的信息恢复上次打开的文件和状态
        self.data: Dict[str, Any] = {}
        try:
            with open(self.settings["data_path"], mode = "r", encoding = self.settings["encoding"]) as file:
                self.data = json.load(file)
        except FileNotFoundError:
            pass
        except Exception as e:
            print(f"读取数据文件时出错: {e}")

        # 在整个 mainloop 中要周期性执行的函数
        # 每一条的格式： [函数, [参数1, 参数2, ...]]
        self.periodically_executed_functions: List[[Callable, List[Any]]] = [
            [self.dump_data, []],
        ]


    def update_menubar(self) -> None:
        """
        根据 self.menu_structure 更新 self.menubar
        """
        self.menubar.delete(0, tk.END)
        construct_menu(self.menubar, self.menu_structure)


    def dump_data(self) -> None:
        """
        导出数据文件 data.json。
        """

        # 写入数据文件
        try:
            with open(self.settings["data_path"], mode = "w", encoding = self.settings["encoding"]) as file:
                json.dump(self.data, file, indent = 4, ensure_ascii = True)
        except Exception as e:
            print(f"写入数据文件时出错: {e}")


    def periodically_execute(self) -> None:
        """
        执行在整个 mainloop 中要周期性执行的函数。
        """
        for (function, args) in self.periodically_executed_functions:
            try:
                function(*args)
            except Exception as error:
                print(f"in reader.periodically_execute: {function.__name__}: {error.__class__.__name__}: {error}")

        # 每隔一定时间再次执行
        self.root.after(self.settings["frequency"], self.periodically_execute)


    def mainloop(self) -> None:
        """
        进入主循环。
        """
        self.periodically_execute()
        self.root.mainloop()

``````



[ReaderAccess.py](.\glueous\ReaderAccess.py) : 
``````python
from __future__ import annotations

import tkinter as tk
from tkinter import ttk
from typing import Any, Dict, Iterable, List, Type, TYPE_CHECKING

if TYPE_CHECKING:
    from .Reader import Reader


class ReaderAccess:
    """
    插件访问 Reader 的接口。
    """

    def __init__(self, reader: Reader):
        # Do not directly access this attribute
        # unless you have a clear understanding of what you are doing.
        self._reader: Reader = reader


    def get_setting(self, key: str, default: Any = None) -> Any:
        """
        访问全局设置。
        """
        return self._reader.settings.get(key, default)


    def set_setting(self, key: str, value: Any) -> None:
        """
        修改全局设置。
        """
        self._reader.settings[key] = value


    def add_menu(self, path: Iterable[str]) -> Dict[str, Any]:
        """
        添加一个空的菜单，其访问路径为 `path` 。
        """
        # 获取菜单结构
        current_menu: Dict[str, List[Dict[str, Any]]] = {"children": self._reader.menu_structure}

        # 遍历路径，逐级查找或创建菜单
        for menu_name in path:
            # 查找当前层级是否已存在同名菜单
            found = False
            for item in current_menu["children"]:
                if (item.get("label") == menu_name) and (item.get("type") == "menu"):
                    current_menu = item
                    found = True
                    break

            # 不存在则创建新菜单
            if not found:
                new_menu = {
                    "type": "menu",
                    "label": menu_name,
                    "tearoff": 0,
                    "children": []
                }
                current_menu["children"].append(new_menu)
                current_menu = new_menu

        self.update_menubar()
        return current_menu


    def add_menu_separator(self, path: Iterable[str]) -> None:
        """
        在访问路径为 `path` 的菜单下添加分割线。

        如果指定菜单不存在，则会新建这个菜单。
        """
        menu = self.add_menu(path)
        menu["children"].append({"type": "seperator"})
        self.update_menubar()


    def add_menu_command(self, path: Iterable[str], **kwargs: Dict[str, Any]) -> None:
        """
        在访问路径为 `path` 的菜单下添加命令。

        如果指定菜单不存在，则会新建这个菜单。

        `kwargs` 传入 `tk.Menu.add_command` 方法。
        """
        menu = self.add_menu(path)
        menu["children"].append({"type": "command", **kwargs})
        self.update_menubar()


    def update_menubar(self) -> None:
        """
        更新菜单栏。
        """
        self._reader.update_menubar()


    def add_tool(
        self,
        Widget: Type, *,
        args: List[Any] = None, kwargs: Dict[str, Any] = None,
        side: str = tk.LEFT, padx: int = 5, pady: int = 5,
    ) -> tk.Widget:
        """
        添加一个工具。

        `Widget` 为继承自 `tk.Widget` 的组件类，如 `tk.Button` ；
        `args` 和 `kwargs` 传入 `Widget` 的构造方法。

        返回创建的组件实例。
        """
        if args is None:
            args = []
        if kwargs is None:
            kwargs = {}
        # 创建组件实例
        widget_instance = Widget(self._reader.toolbar, *args, **kwargs)
        # 添加到工具栏
        widget_instance.pack(side = side, padx = padx, pady = pady)
        return widget_instance


    def bind_root(self, *args, **kwargs) -> None:
        """
        绑定事件到主窗口。
        """
        self._reader.root.bind(*args, **kwargs)


    def bind_notebook(self, *args, **kwargs) -> None:
        """
        绑定事件到标签页。
        """
        self._reader.notebook.bind(*args, **kwargs)


    def get_notebook(self) -> ttk.Notebook:
        """
        获取标签页容器。
        """
        return self._reader.notebook


    def get_data(self) -> Dict[str, Any]:
        """
        返回对应用数据的引用，插件可以写入该对象以实现数据持久化。
        """
        return self._reader.data

``````



[__init__.py](.\glueous\__init__.py) : 
``````python

``````



[FileState.cpython-313.pyc](.\glueous\__pycache__\FileState.cpython-313.pyc) : 


[PluginManager.cpython-313.pyc](.\glueous\__pycache__\PluginManager.cpython-313.pyc) : 


[Reader.cpython-313.pyc](.\glueous\__pycache__\Reader.cpython-313.pyc) : 


[ReaderAccess.cpython-313.pyc](.\glueous\__pycache__\ReaderAccess.cpython-313.pyc) : 


[Tab.cpython-313.pyc](.\glueous\__pycache__\Tab.cpython-313.pyc) : 


[__init__.cpython-313.pyc](.\glueous\__pycache__\__init__.cpython-313.pyc) : 


[Plugin.py](.\glueous_plugin\Plugin.py) : 
``````python
"""
插件基类。
"""
from __future__ import annotations

from abc import ABC, abstractmethod

from typing import List, TYPE_CHECKING
from types import NoneType

if TYPE_CHECKING:
    from glueous.ReaderAccess import ReaderAccess


class Plugin(ABC):
    """
    插件基类，所有插件都应该是它的基类。

    调用示例：

    ```python
    # When the program starts...
    plugins = {}
    your_plugin = YourPlugin(context)
    plugins[your_plugin.name] = your_plugin
    
    for plugin in plugins.value():
        plugin.loaded()

    # When the plugin is triggered...
    your_plugin.run()

    # When the program is about to exit...
    your_plugin.unloaded()
    ```
    """

    def __init__(self, context: ReaderAccess):
        self.context: ReaderAccess = context
        self._able  : bool = True


    @abstractmethod
    def loaded(self) -> None:
        """
        每次启动程序时被调用。
        """
        raise NotImplementedError()


    @abstractmethod
    def run(self) -> None:
        """
        插件执行的主方法。
        """
        raise NotImplementedError()


    @abstractmethod
    def unloaded(self) -> None:
        """
        每次退出程序时被调用。
        """
        raise NotImplementedError()


    @property
    @abstractmethod
    def name(self) -> str:
        """
        插件名，将被用作插件的唯一标识。
        """
        raise NotImplementedError()


    @property
    def description(self) -> str:
        """
        插件描述，子类可以重载。
        """
        return "plugin"


    @property
    def hotkey(self) -> str | None:
        """
        返回默认的快捷键（ self.hotkeys 的第一个元素）。
        """
        if self.hotkeys:
            return self.hotkeys[0]
        return None


    @property
    def hotkeys(self) -> List[str]:
        """
        能够触发该插件的 run 方法的触发快捷键（可以有多个），子类可以定义，格式同 Tkinter 库的热键触发格式。
        """
        return []


    @property
    def able(self) -> bool:
        """
        是否启用该插件。
        """
        return self._able


    def enable(self) -> None:
        """
        启用该插件。
        """
        self._able = True


    def disable(self) -> None:
        """
        禁用该插件。
        """
        self._able = False

``````



[__init__.py](.\glueous_plugin\__init__.py) : 
``````python
from .Plugin import Plugin

``````



[Plugin.cpython-313.pyc](.\glueous_plugin\__pycache__\Plugin.cpython-313.pyc) : 


[__init__.cpython-313.pyc](.\glueous_plugin\__pycache__\__init__.cpython-313.pyc) : 


[main.py](.\main.py) : 
``````python
from config.settings import SETTINGS
from glueous.Reader import Reader

if __name__ == '__main__':
    reader = Reader(SETTINGS)
    reader.mainloop()

``````



[pdf_reader - 副本.py](.\pdf_reader - 副本.py) : 
``````python
import tkinter as tk
from tkinter import filedialog, messagebox, ttk, Menu
import fitz  # PyMuPDF
from PIL import Image, ImageTk
import pyperclip
import os
import importlib.util
import inspect
from pathlib import Path

# 确保plugins文件夹存在
Path("plugins").mkdir(exist_ok=True)




class PDFTab:
    """单个PDF文件的标签页容器，管理单PDF的显示和状态"""
    
    def __init__(self, parent_notebook, file_path=None):
        self.notebook = parent_notebook  # 父标签页容器
        self.frame = ttk.Frame(parent_notebook)  # 标签页内容框架
        self.file_path = file_path  # PDF文件路径
        self.pdf_doc = None  # PyMuPDF文档对象
        self.current_page = 0
        self.total_pages = 0
        self.zoom = 1.0
        self.selected_area = None  # 选中区域 (x1, y1, x2, y2)
        self.text_segments = []  # 当前页文本片段
        self.image_segments = []  # 当前页图像位置
        self.select_rect = None  # 画布上的选择框
        self.last_mouse_pos = (0, 0)  # 最后记录的鼠标位置
        
        # 创建标签页内的UI组件
        self.create_widgets()
        self.bind_events()
        
        # 关键修改：取消初始化时自动打开PDF，改为由外部调用
        # if file_path:
        #     self.open_pdf(file_path)
    
    def create_widgets(self):
        """创建标签页内的显示组件（画布、滚动条等）"""
        # 显示区域（带滚动条）
        self.display_frame = ttk.Frame(self.frame)
        
        self.vscroll = ttk.Scrollbar(self.display_frame, orient=tk.VERTICAL)
        self.vscroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.hscroll = ttk.Scrollbar(self.display_frame, orient=tk.HORIZONTAL)
        self.hscroll.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.canvas = tk.Canvas(
            self.display_frame,
            yscrollcommand=self.vscroll.set,
            xscrollcommand=self.hscroll.set,
            bg="white",
            highlightthickness=0
        )
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.vscroll.config(command=self.canvas.yview)
        self.hscroll.config(command=self.canvas.xview)
        
        self.display_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # 右键菜单
        self.right_click_menu = Menu(self.frame, tearoff=0)
        self.right_click_menu.add_command(label="复制", command=self.copy_legacy)

    def bind_events(self):
        """绑定鼠标事件"""
        self.canvas.bind("<ButtonPress-1>", self.on_mouse_down)  # 鼠标按下
        self.canvas.bind("<B1-Motion>", self.on_mouse_drag)      # 鼠标拖动
        self.canvas.bind("<ButtonRelease-1>", self.on_mouse_up)  # 鼠标释放
        self.canvas.bind("<ButtonPress-3>", self.show_right_click_menu)  # 右键菜单
        self.canvas.bind("<Motion>", self.on_mouse_move)  # 鼠标移动

    def on_mouse_move(self, event):
        """记录鼠标位置"""
        self.last_mouse_pos = (event.x, event.y)

    def open_pdf(self, file_path):
        """打开PDF文件并初始化"""
        try:
            # 关闭已打开的文档
            if self.pdf_doc:
                self.pdf_doc.close()
            
            self.file_path = file_path
            self.pdf_doc = fitz.open(file_path)
            self.total_pages = len(self.pdf_doc)
            self.current_page = 0
            self.zoom = 1.0
            
            # 刷新显示
            self.show_page()
            
            # 更新标签页标题（显示文件名）
            tab_title = os.path.basename(file_path)
            self.notebook.tab(self.frame, text=tab_title)
            
            return True
        except Exception as e:
            messagebox.showerror("错误", f"打开失败: {str(e)}")
            self.reset_tab()
            return False

    def show_page(self):
        """渲染当前页并提取文本和图像坐标"""
        if not self.pdf_doc or not (0 <= self.current_page < self.total_pages):
            return
        
        # 清空画布和缓存
        self.canvas.delete("all")
        self.text_segments = []
        self.image_segments = []
        self.selected_area = None
        
        # 渲染页面图像
        page = self.pdf_doc[self.current_page]
        mat = fitz.Matrix(self.zoom, self.zoom)
        pix = page.get_pixmap(matrix=mat)
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
        self.tk_img = ImageTk.PhotoImage(image=img)
        self.canvas.create_image(0, 0, anchor=tk.NW, image=self.tk_img)
        self.canvas.config(scrollregion=(0, 0, pix.width, pix.height))
        
        # 提取文本片段（带坐标）
        text_blocks = page.get_text("words")  # 格式: (x0, y0, x1, y1, text, ...)
        for block in text_blocks:
            x0, y0, x1, y1, text = block[:5]
            # 转换为缩放后的坐标（与画布显示匹配）
            self.text_segments.append((
                x0 * self.zoom, y0 * self.zoom,
                x1 * self.zoom, y1 * self.zoom,
                text
            ))
        
        # 提取图像位置
        images = page.get_images(full=True)
        for img in images:
            xref = img[0]
            # 获取图像在页面中的位置
            img_rects = page.get_image_rects(xref)
            for rect in img_rects:
                x0, y0, x1, y1 = rect
                self.image_segments.append((
                    x0 * self.zoom, y0 * self.zoom,
                    x1 * self.zoom, y1 * self.zoom,
                    xref  # 图像唯一标识
                ))

    def on_mouse_down(self, event):
        """记录鼠标按下位置（选择起点）"""
        self.start_x = event.x
        self.start_y = event.y
        self.selected_area = None
        if self.select_rect:
            self.canvas.delete(self.select_rect)

    def on_mouse_drag(self, event):
        """绘制选择框（随鼠标拖动更新）"""
        if self.select_rect:
            self.canvas.delete(self.select_rect)
        # 确保选择框坐标正确（左上角到右下角）
        x1, y1 = event.x, event.y
        self.select_rect = self.canvas.create_rectangle(
            min(self.start_x, x1), min(self.start_y, y1),
            max(self.start_x, x1), max(self.start_y, y1),
            outline="blue", dash=(2, 2), fill=""
        )

    def on_mouse_up(self, event):
        """确定选择区域并匹配内容"""
        x1, y1 = event.x, event.y
        # 存储选中区域（缩放后的坐标）
        self.selected_area = (
            min(self.start_x, x1), min(self.start_y, y1),
            max(self.start_x, x1), max(self.start_y, y1)
        )

    def show_right_click_menu(self, event):
        """右键菜单"""
        self.right_click_menu.post(event.x_root, event.y_root)

    def copy_legacy(self):
        """传统复制方法，供右键菜单使用"""
        # 查找CopyPlugin并调用其run方法（通过主程序的插件管理器）
        reader = self.notebook.master  # 获取主程序实例
        for plugin in reader.plugin_manager.plugins:
            if plugin.name == "CopyPlugin":
                plugin.run()
                return
        messagebox.showinfo("提示", "未找到复制插件")

    def prev_page(self):
        """上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_page()
            return True
        return False

    def next_page(self):
        """下一页"""
        if self.current_page < self.total_pages - 1:
            self.current_page += 1
            self.show_page()
            return True
        return False

    def update_zoom(self, zoom_level):
        """更新缩放比例"""
        self.zoom = zoom_level
        self.show_page()

    def get_context(self):
        """获取当前标签页的上下文信息（供插件使用）"""
        return {
            "current_page": self.current_page,
            "total_pages": self.total_pages,
            "selected_area": self.selected_area,
            "mouse_position": self.last_mouse_pos,
            "text_segments": self.text_segments,
            "image_segments": self.image_segments,
            "zoom": self.zoom,
            "pdf_doc": self.pdf_doc,
            "file_path": self.file_path
        }

    def reset_tab(self):
        """重置标签页状态"""
        if self.pdf_doc:
            self.pdf_doc.close()
        self.pdf_doc = None
        self.current_page = 0
        self.total_pages = 0
        self.file_path = None
        self.canvas.delete("all")
        # 仅在frame被管理时修改标签标题
        try:
            self.notebook.tab(self.frame, text="空标签页")
        except tk.TclError:
            # 若frame已被移除，忽略错误
            pass


class PDFReader:
    """主程序类，管理多标签页和全局状态"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("PDF 阅读器（多标签页）")
        self.root.geometry("1200x800")
        
        # 存储所有标签页实例
        self.tabs = []
        
        # 先创建菜单栏和工具栏（关键修改：提前创建工具栏组件）
        self.create_menubar()
        self.create_toolbar()
        
        # 再创建标签页容器和初始标签页
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # 创建初始空标签页
        self.create_new_tab()
        
        # 初始化插件系统
        self.plugin_manager = PluginManager(self)
        self.plugin_manager.load_plugins()
        
        # 更新工具栏状态（与当前标签页联动）
        self.notebook.bind("<<NotebookTabChanged>>", self.update_toolbar_state)
    
    def create_menubar(self):
        """创建菜单栏"""
        menubar = tk.Menu(self.root)
        
        # 文件菜单
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="新建标签页", command=self.create_new_tab, accelerator="Ctrl+T")
        file_menu.add_command(label="打开 PDF", command=self.open_pdf_in_new_tab, accelerator="Ctrl+O")
        file_menu.add_command(label="关闭当前标签页", command=self.close_current_tab, accelerator="Ctrl+W")
        file_menu.add_separator()
        file_menu.add_command(label="退出", command=self.root.quit)
        menubar.add_cascade(label="文件", menu=file_menu)
        
        # 插件菜单
        self.plugin_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="插件", menu=self.plugin_menu)
        
        self.root.config(menu=menubar)
        
        # 绑定菜单快捷键
        self.root.bind("<Control-t>", lambda e: self.create_new_tab())
        self.root.bind("<Control-o>", lambda e: self.open_pdf_in_new_tab())
        self.root.bind("<Control-w>", lambda e: self.close_current_tab())

    def create_toolbar(self):
        """创建工具栏（与当前标签页联动）"""
        toolbar = ttk.Frame(self.root)
        
        # 页面导航
        self.prev_btn = ttk.Button(toolbar, text="上一页", command=self.prev_page)
        self.prev_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.page_label = ttk.Label(toolbar, text="页码: 0/0")
        self.page_label.pack(side=tk.LEFT, padx=10)
        
        self.next_btn = ttk.Button(toolbar, text="下一页", command=self.next_page)
        self.next_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # 缩放控制
        ttk.Label(toolbar, text="缩放:").pack(side=tk.LEFT, padx=10)
        self.zoom_var = tk.DoubleVar(value=1.0)
        self.zoom_scale = ttk.Scale(
            toolbar, from_=0.5, to=2.0, variable=self.zoom_var, 
            command=lambda v: self.update_zoom(float(v))
        )
        self.zoom_scale.pack(side=tk.LEFT, padx=5)
        self.zoom_label = ttk.Label(toolbar, text="100%")
        self.zoom_label.pack(side=tk.LEFT, padx=5)
        
        toolbar.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)

    def create_new_tab(self):
        """创建新的空标签页"""
        new_tab = PDFTab(self.notebook)
        self.notebook.add(new_tab.frame, text="空标签页")
        self.notebook.select(new_tab.frame)  # 激活新标签页
        self.tabs.append(new_tab)  # 新增：将标签页加入列表
        self.update_toolbar_state()  # 更新工具栏状态

    def open_pdf_in_new_tab(self):
        """在新标签页中打开PDF"""
        file_path = filedialog.askopenfilename(filetypes=[("PDF 文件", "*.pdf"), ("EPUB 文件", "*.epub")])
        if not file_path:
            return
        
        # 1. 创建新标签页（不自动打开PDF）
        new_tab = PDFTab(self.notebook)
        # 2. 先将frame添加到Notebook（关键：确保frame被管理）
        self.notebook.add(new_tab.frame, text="加载中...")
        # 3. 再调用open_pdf打开文件（此时frame已被管理）
        if new_tab.open_pdf(file_path):
            # 打开成功后更新标签标题
            self.notebook.tab(new_tab.frame, text=os.path.basename(file_path))
        # 4. 激活新标签页
        self.notebook.select(new_tab.frame)
        # 5. 添加到标签页列表并更新工具栏
        self.tabs.append(new_tab)
        self.update_toolbar_state()

    def get_current_tab(self):
        """获取当前激活的标签页实例（修复路径字符串问题）"""
        if not self.tabs:
            return None
        
        # 1. 获取当前选中标签页的路径字符串
        current_frame_path = self.notebook.select()
        if not current_frame_path:
            return None
        
        # 2. 将路径字符串转换为窗口对象
        try:
            current_frame = self.root.nametowidget(current_frame_path)
        except KeyError:
            return None
        
        # 3. 从标签页列表中找到匹配的PDFTab
        for tab in self.tabs:
            if tab.frame == current_frame:
                return tab
        return None

    def close_current_tab(self):
        """关闭当前标签页"""
        current_frame_path = self.notebook.select()
        if not current_frame_path:
            return
        
        # 至少保留一个标签页
        if self.notebook.index("end") <= 1:
            messagebox.showinfo("提示", "至少保留一个标签页")
            return
        
        # 从列表中移除当前标签页
        current_tab = self.get_current_tab()
        if current_tab in self.tabs:
            self.tabs.remove(current_tab)
        
        # 关闭文档并移除标签页
        if current_tab:
            current_tab.reset_tab()
        self.notebook.forget(current_frame_path)
        self.update_toolbar_state()

    def prev_page(self):
        """当前标签页上一页"""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.prev_page()
            self.update_page_label()

    def next_page(self):
        """当前标签页下一页"""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.next_page()
            self.update_page_label()

    def update_zoom(self, zoom_level):
        """更新当前标签页的缩放比例"""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.update_zoom(zoom_level)
            self.zoom_label.config(text=f"{int(zoom_level * 100)}%")

    def update_page_label(self):
        """更新页码标签（显示当前标签页的页码）"""
        current_tab = self.get_current_tab()
        if current_tab and current_tab.total_pages > 0:
            self.page_label.config(
                text=f"页码: {current_tab.current_page + 1}/{current_tab.total_pages}"
            )
        else:
            self.page_label.config(text="页码: 0/0")

    def update_toolbar_state(self, event=None):
        """根据当前标签页状态更新工具栏"""
        current_tab = self.get_current_tab()
        if current_tab and current_tab.total_pages > 0:
            # 启用导航按钮并更新状态
            self.prev_btn.config(state=tk.NORMAL)
            self.next_btn.config(state=tk.NORMAL)
            self.zoom_scale.set(current_tab.zoom)
            self.zoom_label.config(text=f"{int(current_tab.zoom * 100)}%")
            self.update_page_label()
        else:
            # 禁用导航按钮（空标签页）
            self.prev_btn.config(state=tk.DISABLED)
            self.next_btn.config(state=tk.DISABLED)
            self.page_label.config(text="页码: 0/0")


if __name__ == "__main__":
    root = tk.Tk()
    app = PDFReader(root)
    root.mainloop()

``````



[pdf_reader.py](.\pdf_reader.py) : 
``````python
import tkinter as tk
from tkinter import filedialog, messagebox, ttk, Menu
import fitz  # PyMuPDF
from PIL import Image, ImageTk
import pyperclip
import os
import importlib.util
import inspect
from pathlib import Path

# 确保plugins文件夹存在
Path("plugins").mkdir(exist_ok=True)

class PluginBase:
    """插件基类，所有插件必须继承此类并实现必要的方法"""
    
    # 插件名称，子类必须定义
    name = "BasePlugin"
    
    # 插件描述，子类可以定义
    description = "基础插件类"
    
    # 触发快捷键，子类可以定义，格式如 "<Control-c>"
    hotkey = None
    
    def __init__(self, reader):
        """初始化插件
        
        Args:
            reader: PDFReader实例，提供对主程序的访问
        """
        self.reader = reader
    
    def run(self, event=None):
        """插件执行的主方法，子类必须实现"""
        raise NotImplementedError("插件必须实现run方法")
    
    def get_context(self):
        """获取当前激活标签页的上下文信息"""
        current_tab = self.reader.get_current_tab()
        if not current_tab:
            return None
        return current_tab.get_context()


class PluginManager:
    """插件管理器，负责加载和管理插件"""
    
    def __init__(self, reader):
        self.reader = reader
        self.plugins = []  # 存储所有加载的插件实例
        self.hotkey_map = {}  # 快捷键到插件的映射
    
    def load_plugins(self):
        """加载plugins文件夹中的所有插件"""
        plugins_dir = "plugins"
        self.plugins = []
        self.hotkey_map = {}
        
        # 遍历plugins文件夹中的所有Python文件（跳过以下划线开头的文件）
        for filename in os.listdir(plugins_dir):
            if filename.endswith(".py") and not filename.startswith("_"):
                module_name = filename[:-3]
                file_path = os.path.join(plugins_dir, filename)
                
                try:
                    # 动态导入模块
                    spec = importlib.util.spec_from_file_location(module_name, file_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    
                    # 查找继承自PluginBase的类
                    for name, cls in inspect.getmembers(module, inspect.isclass):
                        if issubclass(cls, PluginBase) and cls != PluginBase:
                            # 创建插件实例
                            plugin_instance = cls(self.reader)
                            self.plugins.append(plugin_instance)
                            
                            # 注册快捷键
                            if plugin_instance.hotkey:
                                self.hotkey_map[plugin_instance.hotkey] = plugin_instance
                            
                            print(f"加载插件: {plugin_instance.name}")
                except Exception as e:
                    print(f"加载插件 {filename} 失败: {str(e)}")
        
        # 绑定所有快捷键到主窗口（作用于当前激活标签页）
        self.bind_hotkeys()
    
    def bind_hotkeys(self):
        """为插件绑定快捷键"""
        for hotkey, plugin in self.hotkey_map.items():
            self.reader.root.bind(hotkey, lambda e, p=plugin: p.run(e))
            print(f"绑定快捷键 {hotkey} 到插件 {plugin.name}")


class PDFTab:
    """单个PDF文件的标签页容器，管理单PDF的显示和状态"""
    
    def __init__(self, parent_notebook, file_path=None):
        self.notebook = parent_notebook  # 父标签页容器
        self.frame = ttk.Frame(parent_notebook)  # 标签页内容框架
        self.file_path = file_path  # PDF文件路径
        self.pdf_doc = None  # PyMuPDF文档对象
        self.current_page = 0
        self.total_pages = 0
        self.zoom = 1.0
        self.selected_area = None  # 选中区域 (x1, y1, x2, y2)
        self.text_segments = []  # 当前页文本片段
        self.image_segments = []  # 当前页图像位置
        self.select_rect = None  # 画布上的选择框
        self.last_mouse_pos = (0, 0)  # 最后记录的鼠标位置
        
        # 创建标签页内的UI组件
        self.create_widgets()
        self.bind_events()
        
        # 关键修改：取消初始化时自动打开PDF，改为由外部调用
        # if file_path:
        #     self.open_pdf(file_path)
    
    def create_widgets(self):
        """创建标签页内的显示组件（画布、滚动条等）"""
        # 显示区域（带滚动条）
        self.display_frame = ttk.Frame(self.frame)
        
        self.vscroll = ttk.Scrollbar(self.display_frame, orient=tk.VERTICAL)
        self.vscroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.hscroll = ttk.Scrollbar(self.display_frame, orient=tk.HORIZONTAL)
        self.hscroll.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.canvas = tk.Canvas(
            self.display_frame,
            yscrollcommand=self.vscroll.set,
            xscrollcommand=self.hscroll.set,
            bg="white",
            highlightthickness=0
        )
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.vscroll.config(command=self.canvas.yview)
        self.hscroll.config(command=self.canvas.xview)
        
        self.display_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # 右键菜单
        self.right_click_menu = Menu(self.frame, tearoff=0)
        self.right_click_menu.add_command(label="复制", command=self.copy_legacy)

    def bind_events(self):
        """绑定鼠标事件"""
        self.canvas.bind("<ButtonPress-1>", self.on_mouse_down)  # 鼠标按下
        self.canvas.bind("<B1-Motion>", self.on_mouse_drag)      # 鼠标拖动
        self.canvas.bind("<ButtonRelease-1>", self.on_mouse_up)  # 鼠标释放
        self.canvas.bind("<ButtonPress-3>", self.show_right_click_menu)  # 右键菜单
        self.canvas.bind("<Motion>", self.on_mouse_move)  # 鼠标移动

    def on_mouse_move(self, event):
        """记录鼠标位置"""
        self.last_mouse_pos = (event.x, event.y)

    def open_pdf(self, file_path):
        """打开PDF文件并初始化"""
        try:
            # 关闭已打开的文档
            if self.pdf_doc:
                self.pdf_doc.close()
            
            self.file_path = file_path
            self.pdf_doc = fitz.open(file_path)
            self.total_pages = len(self.pdf_doc)
            self.current_page = 0
            self.zoom = 1.0
            
            # 刷新显示
            self.show_page()
            
            # 更新标签页标题（显示文件名）
            tab_title = os.path.basename(file_path)
            self.notebook.tab(self.frame, text=tab_title)
            
            return True
        except Exception as e:
            messagebox.showerror("错误", f"打开失败: {str(e)}")
            self.reset_tab()
            return False

    def show_page(self):
        """渲染当前页并提取文本和图像坐标"""
        if not self.pdf_doc or not (0 <= self.current_page < self.total_pages):
            return
        
        # 清空画布和缓存
        self.canvas.delete("all")
        self.text_segments = []
        self.image_segments = []
        self.selected_area = None
        
        # 渲染页面图像
        page = self.pdf_doc[self.current_page]
        mat = fitz.Matrix(self.zoom, self.zoom)
        pix = page.get_pixmap(matrix=mat)
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
        self.tk_img = ImageTk.PhotoImage(image=img)
        self.canvas.create_image(0, 0, anchor=tk.NW, image=self.tk_img)
        self.canvas.config(scrollregion=(0, 0, pix.width, pix.height))
        
        # 提取文本片段（带坐标）
        text_blocks = page.get_text("words")  # 格式: (x0, y0, x1, y1, text, ...)
        for block in text_blocks:
            x0, y0, x1, y1, text = block[:5]
            # 转换为缩放后的坐标（与画布显示匹配）
            self.text_segments.append((
                x0 * self.zoom, y0 * self.zoom,
                x1 * self.zoom, y1 * self.zoom,
                text
            ))
        
        # 提取图像位置
        images = page.get_images(full=True)
        for img in images:
            xref = img[0]
            # 获取图像在页面中的位置
            img_rects = page.get_image_rects(xref)
            for rect in img_rects:
                x0, y0, x1, y1 = rect
                self.image_segments.append((
                    x0 * self.zoom, y0 * self.zoom,
                    x1 * self.zoom, y1 * self.zoom,
                    xref  # 图像唯一标识
                ))

    def on_mouse_down(self, event):
        """记录鼠标按下位置（选择起点）"""
        self.start_x = event.x
        self.start_y = event.y
        self.selected_area = None
        if self.select_rect:
            self.canvas.delete(self.select_rect)

    def on_mouse_drag(self, event):
        """绘制选择框（随鼠标拖动更新）"""
        if self.select_rect:
            self.canvas.delete(self.select_rect)
        # 确保选择框坐标正确（左上角到右下角）
        x1, y1 = event.x, event.y
        self.select_rect = self.canvas.create_rectangle(
            min(self.start_x, x1), min(self.start_y, y1),
            max(self.start_x, x1), max(self.start_y, y1),
            outline="blue", dash=(2, 2), fill=""
        )

    def on_mouse_up(self, event):
        """确定选择区域并匹配内容"""
        x1, y1 = event.x, event.y
        # 存储选中区域（缩放后的坐标）
        self.selected_area = (
            min(self.start_x, x1), min(self.start_y, y1),
            max(self.start_x, x1), max(self.start_y, y1)
        )

    def show_right_click_menu(self, event):
        """右键菜单"""
        self.right_click_menu.post(event.x_root, event.y_root)

    def copy_legacy(self):
        """传统复制方法，供右键菜单使用"""
        # 查找CopyPlugin并调用其run方法（通过主程序的插件管理器）
        reader = self.notebook.master  # 获取主程序实例
        for plugin in reader.plugin_manager.plugins:
            if plugin.name == "CopyPlugin":
                plugin.run()
                return
        messagebox.showinfo("提示", "未找到复制插件")

    def prev_page(self):
        """上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_page()
            return True
        return False

    def next_page(self):
        """下一页"""
        if self.current_page < self.total_pages - 1:
            self.current_page += 1
            self.show_page()
            return True
        return False

    def update_zoom(self, zoom_level):
        """更新缩放比例"""
        self.zoom = zoom_level
        self.show_page()

    def get_context(self):
        """获取当前标签页的上下文信息（供插件使用）"""
        return {
            "current_page": self.current_page,
            "total_pages": self.total_pages,
            "selected_area": self.selected_area,
            "mouse_position": self.last_mouse_pos,
            "text_segments": self.text_segments,
            "image_segments": self.image_segments,
            "zoom": self.zoom,
            "pdf_doc": self.pdf_doc,
            "file_path": self.file_path
        }

    def reset_tab(self):
        """重置标签页状态"""
        if self.pdf_doc:
            self.pdf_doc.close()
        self.pdf_doc = None
        self.current_page = 0
        self.total_pages = 0
        self.file_path = None
        self.canvas.delete("all")
        # 仅在frame被管理时修改标签标题
        try:
            self.notebook.tab(self.frame, text="空标签页")
        except tk.TclError:
            # 若frame已被移除，忽略错误
            pass


class PDFReader:
    """主程序类，管理多标签页和全局状态"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("PDF 阅读器（多标签页）")
        self.root.geometry("1200x800")
        
        # 存储所有标签页实例
        self.tabs = []
        
        # 先创建菜单栏和工具栏（关键修改：提前创建工具栏组件）
        self.create_menubar()
        self.create_toolbar()
        
        # 再创建标签页容器和初始标签页
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # 创建初始空标签页
        self.create_new_tab()
        
        # 初始化插件系统
        self.plugin_manager = PluginManager(self)
        self.plugin_manager.load_plugins()
        
        # 更新工具栏状态（与当前标签页联动）
        self.notebook.bind("<<NotebookTabChanged>>", self.update_toolbar_state)
    
    def create_menubar(self):
        """创建菜单栏"""
        menubar = tk.Menu(self.root)
        
        # 文件菜单
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="新建标签页", command=self.create_new_tab, accelerator="Ctrl+T")
        file_menu.add_command(label="打开 PDF", command=self.open_pdf_in_new_tab, accelerator="Ctrl+O")
        file_menu.add_command(label="关闭当前标签页", command=self.close_current_tab, accelerator="Ctrl+W")
        file_menu.add_separator()
        file_menu.add_command(label="退出", command=self.root.quit)
        menubar.add_cascade(label="文件", menu=file_menu)
        
        # 插件菜单
        self.plugin_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="插件", menu=self.plugin_menu)
        
        self.root.config(menu=menubar)
        
        # 绑定菜单快捷键
        self.root.bind("<Control-t>", lambda e: self.create_new_tab())
        self.root.bind("<Control-o>", lambda e: self.open_pdf_in_new_tab())
        self.root.bind("<Control-w>", lambda e: self.close_current_tab())

    def create_toolbar(self):
        """创建工具栏（与当前标签页联动）"""
        toolbar = ttk.Frame(self.root)
        
        # 页面导航
        self.prev_btn = ttk.Button(toolbar, text="上一页", command=self.prev_page)
        self.prev_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.page_label = ttk.Label(toolbar, text="页码: 0/0")
        self.page_label.pack(side=tk.LEFT, padx=10)
        
        self.next_btn = ttk.Button(toolbar, text="下一页", command=self.next_page)
        self.next_btn.pack(side=tk.LEFT, padx=5, pady=5)
        
        # 缩放控制
        ttk.Label(toolbar, text="缩放:").pack(side=tk.LEFT, padx=10)
        self.zoom_var = tk.DoubleVar(value=1.0)
        self.zoom_scale = ttk.Scale(
            toolbar, from_=0.5, to=2.0, variable=self.zoom_var, 
            command=lambda v: self.update_zoom(float(v))
        )
        self.zoom_scale.pack(side=tk.LEFT, padx=5)
        self.zoom_label = ttk.Label(toolbar, text="100%")
        self.zoom_label.pack(side=tk.LEFT, padx=5)
        
        toolbar.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)

    def create_new_tab(self):
        """创建新的空标签页"""
        new_tab = PDFTab(self.notebook)
        self.notebook.add(new_tab.frame, text="空标签页")
        self.notebook.select(new_tab.frame)  # 激活新标签页
        self.tabs.append(new_tab)  # 新增：将标签页加入列表
        self.update_toolbar_state()  # 更新工具栏状态

    def open_pdf_in_new_tab(self):
        """在新标签页中打开PDF"""
        file_path = filedialog.askopenfilename(filetypes=[("PDF 文件", "*.pdf"), ("EPUB 文件", "*.epub")])
        if not file_path:
            return
        
        # 1. 创建新标签页（不自动打开PDF）
        new_tab = PDFTab(self.notebook)
        # 2. 先将frame添加到Notebook（关键：确保frame被管理）
        self.notebook.add(new_tab.frame, text="加载中...")
        # 3. 再调用open_pdf打开文件（此时frame已被管理）
        if new_tab.open_pdf(file_path):
            # 打开成功后更新标签标题
            self.notebook.tab(new_tab.frame, text=os.path.basename(file_path))
        # 4. 激活新标签页
        self.notebook.select(new_tab.frame)
        # 5. 添加到标签页列表并更新工具栏
        self.tabs.append(new_tab)
        self.update_toolbar_state()

    def get_current_tab(self):
        """获取当前激活的标签页实例（修复路径字符串问题）"""
        if not self.tabs:
            return None
        
        # 1. 获取当前选中标签页的路径字符串
        current_frame_path = self.notebook.select()
        if not current_frame_path:
            return None
        
        # 2. 将路径字符串转换为窗口对象
        try:
            current_frame = self.root.nametowidget(current_frame_path)
        except KeyError:
            return None
        
        # 3. 从标签页列表中找到匹配的PDFTab
        for tab in self.tabs:
            if tab.frame == current_frame:
                return tab
        return None

    def close_current_tab(self):
        """关闭当前标签页"""
        current_frame_path = self.notebook.select()
        if not current_frame_path:
            return
        
        # 至少保留一个标签页
        if self.notebook.index("end") <= 1:
            messagebox.showinfo("提示", "至少保留一个标签页")
            return
        
        # 从列表中移除当前标签页
        current_tab = self.get_current_tab()
        if current_tab in self.tabs:
            self.tabs.remove(current_tab)
        
        # 关闭文档并移除标签页
        if current_tab:
            current_tab.reset_tab()
        self.notebook.forget(current_frame_path)
        self.update_toolbar_state()

    def prev_page(self):
        """当前标签页上一页"""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.prev_page()
            self.update_page_label()

    def next_page(self):
        """当前标签页下一页"""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.next_page()
            self.update_page_label()

    def update_zoom(self, zoom_level):
        """更新当前标签页的缩放比例"""
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.update_zoom(zoom_level)
            self.zoom_label.config(text=f"{int(zoom_level * 100)}%")

    def update_page_label(self):
        """更新页码标签（显示当前标签页的页码）"""
        current_tab = self.get_current_tab()
        if current_tab and current_tab.total_pages > 0:
            self.page_label.config(
                text=f"页码: {current_tab.current_page + 1}/{current_tab.total_pages}"
            )
        else:
            self.page_label.config(text="页码: 0/0")

    def update_toolbar_state(self, event=None):
        """根据当前标签页状态更新工具栏"""
        current_tab = self.get_current_tab()
        if current_tab and current_tab.total_pages > 0:
            # 启用导航按钮并更新状态
            self.prev_btn.config(state=tk.NORMAL)
            self.next_btn.config(state=tk.NORMAL)
            self.zoom_scale.set(current_tab.zoom)
            self.zoom_label.config(text=f"{int(current_tab.zoom * 100)}%")
            self.update_page_label()
        else:
            # 禁用导航按钮（空标签页）
            self.prev_btn.config(state=tk.DISABLED)
            self.next_btn.config(state=tk.DISABLED)
            self.page_label.config(text="页码: 0/0")


if __name__ == "__main__":
    root = tk.Tk()
    app = PDFReader(root)
    root.mainloop()

``````



[Close.py](.\plugins\Tab\File\Close.py) : 
``````python
"""
关闭当前标签页。
"""

from glueous_plugin import Plugin


class ClosePlugin(Plugin):
    """
    关闭当前标签页插件：允许用户关闭当前打开的文件标签页。
    """

    # 插件信息
    name = "ClosePlugin"
    description = "关闭当前标签页，快捷键: Ctrl+W"

    # 快捷键设置
    hotkeys = ["<Control-w>"]

    def loaded(self) -> None:
        """
        注册菜单项。
        """
        self.context.add_menu_command(
            path = ["文件"],
            label = "关闭",
            command = self.run,
            accelerator = self.hotkey
        )


    def run(self) -> None:
        """
        执行关闭当前标签页操作。
        """
        current_tab = self.context.get_current_tab()
        if current_tab is None:
            return

        # 关闭当前标签页
        self.context.close_tab(current_tab)


    def unloaded(self) -> None:
        return

``````



[Open.py](.\plugins\Tab\File\Open.py) : 
``````python
"""
用于打开文件的插件。
"""

from tkinter import filedialog, messagebox
import os
from glueous_plugin import Plugin


class OpenPlugin(Plugin):
    """
    打开文件插件：允许用户选择并打开PDF或EPUB文件。
    """

    # 插件信息
    name = "OpenPlugin"
    description = "打开PDF或EPUB文件，快捷键: Ctrl+O"

    # 快捷键设置
    hotkeys = ["<Control-o>"]

    def loaded(self) -> None:
        """
        注册菜单项。
        """
        self.context.add_menu_command(
            path = ["文件"],
            label = "打开",
            command = self.run,
            accelerator = self.hotkey
        )


    def run(self) -> None:
        """
        执行打开文件操作。
        """

        # 打开文件选择对话框
        file_path = filedialog.askopenfilename(
            title="选择要打开的文件",
            filetypes=[
                ("PDF 文件", "*.pdf"),
                ("EPUB 文件", "*.epub"),
                ("所有文件", "*.*")
            ]
        )

        if not file_path:
            return

        # 如果用户选择了文件
        # 检查文件是否存在
        if not os.path.exists(file_path):
            messagebox.showerror("错误", f"文件不存在: {file_path}")
            return

        # 创建新标签页
        self.context.create_tab(file_path)
        self.context.update_page_number()
        self.context.update_page_turning_button()


    def unloaded(self) -> None:
        return

``````



[Close.cpython-313.pyc](.\plugins\Tab\File\__pycache__\Close.cpython-313.pyc) : 


[Open.cpython-313.pyc](.\plugins\Tab\File\__pycache__\Open.cpython-313.pyc) : 


[FileState.py](.\plugins\Tab\FileState.py) : 
``````python
r"""
FileState 类。
"""

from __future__ import annotations

from typing import Any, Dict, List


class Favorite:
    """
    一条收藏记录。
    """

    def __init__(self, page_no: int, name: str = ""):
        self.page_no: int = page_no # 页码
        self.name   : str = name    # 名称


    @classmethod
    def from_json(cls, json_obj: Dict[str, Any]) -> Favorite:
        """
        从 JSON 数据构造对象。

        Params:

        - `json_obj`: JSON 对象，如：
            
            ```json
            {
                "name": "哈密顿图",
                "page_no": 104
            }
            ```

        Return:

        - 一个 Favorite 对象。
        """
        if "page_no" not in json_obj:
            raise ValueError(f"missing field `page_no` in JSON object `{json_obj}`.")
        return cls(page_no = json_obj["page_no"], name = json_obj.get("name", ""))


    def to_json(self) -> Dict[str, Any]:
        """
        将对象序列化为 JSON 对象。

        Return:

        - 一个字典，如：

            ```json
            {
                "name": "哈密顿图",
                "page_no": 104
            }
            ```
        """
        return {
            "name": self.name,
            "page_no": self.page_no
        }



class FileState:
    """
    FileState 类，记录 Tab 类的状态，可以序列化为 JSON 对象来存储，用于在下次重新打开程序时能恢复到上次打开时的状态。
    """

    def __init__(self, file_path: str = ""):
        """
        默认构造方法，只要提供 `file_path` 参数。
        """
        # 绝对路径
        self.file_path: str = file_path

        # 这本书里收藏的条目
        self.favorites: List[Favorite] = []

        # “固定标签页”开关：`true` 时，关闭所有文档也不会把这本书关掉
        self.is_pinned = False

        # 文件被删或移动
        self.is_missing = False

        # 这本书累计被打开过的次数
        self.open_count = 0

        # 如果 `true`，下次打开它时会忽略下面所有个性化状态（相当于“恢复默认视图”）
        self.use_default_state = False

        # 页面布局：
        # - `single page` / `continuous` / `facing` / `book view`
        self.display_mode = "continuous"

        # 客户区左上角的滚动偏移量（单位：逻辑像素）
        self.scroll_pos = (0.0, 0.0)

        # 当前“活跃页”编号（1-based）
        self.page_no = 1

        # 缩放百分比
        self.zoom = 100.0

        # 页面旋转角度，0/90/180/270 四选一
        self.rotation = 0

        # 主窗体状态码：
        # - 0 = 普通/还原
        # - 1 = 最大化
        # - 2 = 最小化
        self.window_state = 0

        # 窗体几何：x y width height（单位：屏幕像素，含边框）。
        self.window_pos = (0, 0, 0, 0)

        # 左侧“目录/书签”面板是否展开。`false` 表示收起。
        self.show_toc = False

        # 如果目录或注释面板被打开，它的宽度是多少像素。
        self.sidebar_dx = 572

        # 是否按“从右到左”顺序显示对页（对阿拉伯/希伯来文 PDF 有用）。普通文档保持 `false`。
        self.display_r2l = False

        # 标记 PDF 重新解析/重载的计数
        self.reparse_idx = 0


    @classmethod
    def from_json(cls, json_obj: Dict[str, Any]) -> FileState:
        """
        从 JSON 数据构造对象。

        Params:

        - `json_obj`: JSON 对象，如：
            
            ```json
            {
                "file_path": "C:\\\\Users\\\\Administrator\\\\Documents\\\\example.pdf",
                "favorites": [
                    {
                        "name": "哈密顿图",
                        "page_no": 104
                    }
                ],
                "is_pinned": false,
                "is_missing": false,
                "open_count": 12,
                "use_default_state": false,
                "display_mode": "continuous",
                "scroll_pos": [0.0, 0.0],
                "page_no": 1,
                "zoom": 100.0,
                "rotation": 0,
                "window_state": 0,
                "window_pos": [0, 0, 0, 0],
                "show_toc": false,
                "sidebar_dx": 572,
                "display_r2l": false,
                "reparse_idx": 0
            }
            ```

        Return:

        - 一个 FileState 对象。
        """
        if "file_path" not in json_obj:
            raise ValueError(f"missing field `file_path` in JSON object `{json_obj}`.")

        instance = cls(file_path = json_obj["file_path"])

        # 基本类型字段
        instance.is_pinned          = json_obj.get("is_pinned", False)
        instance.is_missing         = json_obj.get("is_missing", False)
        instance.open_count         = json_obj.get("open_count", 0)
        instance.use_default_state  = json_obj.get("use_default_state", False)
        instance.display_mode       = json_obj.get("display_mode", "continuous")
        instance.page_no            = json_obj.get("page_no", 1)
        instance.zoom               = json_obj.get("zoom", 100.0)
        instance.rotation           = json_obj.get("rotation", 0)
        instance.window_state       = json_obj.get("window_state", 0)
        instance.show_toc           = json_obj.get("show_toc", False)
        instance.sidebar_dx         = json_obj.get("sidebar_dx", 572)
        instance.display_r2l        = json_obj.get("display_r2l", False)
        instance.reparse_idx        = json_obj.get("reparse_idx", 0)

        # 元组类型字段
        scroll_pos = json_obj.get("scroll_pos", [0.0, 0.0])
        instance.scroll_pos = (float(scroll_pos[0]), float(scroll_pos[1]))

        window_pos = json_obj.get("window_pos", [0, 0, 0, 0])
        instance.window_pos = (int(window_pos[0]), int(window_pos[1]), int(window_pos[2]), int(window_pos[3]))

        # 列表类型字段
        instance.favorites = [Favorite.from_json(fav) for fav in json_obj.get("favorites", [])]

        return instance


    def to_json(self) -> Dict[str, Any]:
        """
        将对象序列化为 JSON 对象。

        Return:

        - 一个字典，如：

            ```json
            {
                "file_path": "C:\\\\Users\\\\Administrator\\\\Documents\\\\example.pdf",
                "favorites": [
                    {
                        "name": "哈密顿图",
                        "page_no": 104
                    }
                ],
                "is_pinned": false,
                "is_missing": false,
                "open_count": 12,
                "use_default_state": false,
                "display_mode": "continuous",
                "scroll_pos": [0.0, 0.0],
                "page_no": 1,
                "zoom": 100.0,
                "rotation": 0,
                "window_state": 0,
                "window_pos": [0, 0, 0, 0],
                "show_toc": false,
                "sidebar_dx": 572,
                "display_r2l": false,
                "reparse_idx": 0
            }
            ```
        """
        return {
            "file_path"         : self.file_path,
            "favorites"         : [fav.to_json() for fav in self.favorites],
            "is_pinned"         : self.is_pinned,
            "is_missing"        : self.is_missing,
            "open_count"        : self.open_count,
            "use_default_state" : self.use_default_state,
            "display_mode"      : self.display_mode,
            "scroll_pos"        : list(self.scroll_pos),
            "page_no"           : self.page_no,
            "zoom"              : self.zoom,
            "rotation"          : self.rotation,
            "window_state"      : self.window_state,
            "window_pos"        : list(self.window_pos),
            "show_toc"          : self.show_toc,
            "sidebar_dx"        : self.sidebar_dx,
            "display_r2l"       : self.display_r2l,
            "reparse_idx"       : self.reparse_idx
        }

``````



[PageDown.py](.\plugins\Tab\PageTurning\PageDown.py) : 
``````python
"""
下一页。
"""

from tkinter import ttk
from typing import override
from types import MethodType

from glueous import ReaderAccess
from glueous_plugin import Plugin


class PageDownPlugin(Plugin):
    """
    下一页插件：允许用户通过快捷键或菜单项切换到下一页。
    """

    # 插件信息
    name = "PageDownPlugin"
    description = "切换到下一页，快捷键: PageDown"

    # 快捷键设置
    hotkeys = ["<Next>"]  # 对应 PageDown 键


    @staticmethod
    def update_page_turning_button(access: ReaderAccess, event = None) -> None:
        """
        更新 prev_button 和 next_button 的启用/禁用状态。
        """
        # 获取“上一页”和“下一页”按钮
        prev_button = access.get_prev_button()
        next_button = access.get_next_button()

        current_tab = access.get_current_tab()
        if current_tab is None:
            prev_button.config(state = "disabled")
            next_button.config(state = "disabled")
            return

        # 检查当前页码并更新按钮状态
        if current_tab.page_no <= 0:
            prev_button.config(state = "disabled")
        else:
            prev_button.config(state = "normal")

        if current_tab.page_no >= current_tab.total_pages - 1:
            next_button.config(state = "disabled")
        else:
            next_button.config(state = "normal")


    @override
    def loaded(self) -> None:
        """
        注册菜单项、快捷键、“下一页”按钮。
        """
        # 注册菜单项、快捷键
        self.context.add_menu_command(
            path = ["前往"],
            label = "下一页",
            command = self.run,
            accelerator = self.hotkey
        )

        # “下一页”按钮
        next_btn = self.context.add_tool(
            ttk.Button,
            kwargs = {
                "text": "→",
                "command": self.run,
                "width": 3,
            }
        )

        # 将这个按钮组件添加到 context 中，以便其他插件访问
        self.context.get_next_button = lambda: next_btn
        self.context.update_page_turning_button = MethodType(self.update_page_turning_button, self.context)

        # 绑定标签页切换事件，以更新按钮显示
        self.context.bind_notebook("<<NotebookTabChanged>>", self.context.update_page_turning_button)


    @override
    def run(self) -> None:
        """
        执行下一页操作。
        """
        current_tab = self.context.get_current_tab()
        if current_tab is None:
            return

        # 切换到下一页
        if current_tab.page_no < current_tab.total_pages - 1:
            current_tab.page_no += 1
            current_tab.show_page()
            self.context.update_page_number()
            self.context.update_page_turning_button()
        else:
            print("已经是最后一页")


    @override
    def unloaded(self) -> None:
        pass

``````



[PageNo.py](.\plugins\Tab\PageTurning\PageNo.py) : 
``````python
"""
显示当前页码。
"""

from tkinter import ttk
from typing import override

from glueous_plugin import Plugin


class PageNoPlugin(Plugin):
    """
    页码显示插件：在状态栏显示当前页码和总页数。
    """

    # 插件信息
    name = "PageNoPlugin"
    description = "在状态栏显示当前页码和总页数"


    @override
    def loaded(self) -> None:
        """
        初始化页码标签并添加到状态栏。
        """
        # 创建页码显示标签
        self.page_label = self.context.add_tool(
            ttk.Label,
            padx = 10,
            kwargs = {
                "text": "0/0",
            }
        )

        # 绑定标签页切换事件，以更新页码显示
        self.context.bind_notebook("<<NotebookTabChanged>>", self.update_page_number)

        # 方便其他插件调用
        self.context.update_page_number = self.update_page_number


    def update_page_number(self, event = None) -> None:
        """
        更新页码显示。
        """
        current_tab = self.context.get_current_tab()
        if current_tab and current_tab.total_pages > 0:
            self.page_label.config(
                text=f"{current_tab.page_no + 1}/{current_tab.total_pages}"
            )
        else:
            self.page_label.config(text = "0/0")


    @override
    def run(self) -> None:
        """
        插件执行方法（此处无需特殊处理）。
        """
        pass


    @override
    def unloaded(self) -> None:
        pass

``````



[PageUp.py](.\plugins\Tab\PageTurning\PageUp.py) : 
``````python
"""
上一页。
"""

from tkinter import ttk
from typing import override

from glueous_plugin import Plugin


class PageUpPlugin(Plugin):
    """
    上一页插件：允许用户通过快捷键或菜单项切换到上一页。
    """

    # 插件信息
    name = "PageUpPlugin"
    description = "切换到上一页，快捷键: PageUp"

    # 快捷键设置
    hotkeys = ["<Prior>"]  # 对应 PageUp 键


    @override
    def loaded(self) -> None:
        """
        注册菜单项、快捷键、“上一页”按钮。
        """
        # 注册菜单项、快捷键
        self.context.add_menu_command(
            path = ["前往"],
            label = "上一页",
            command = self.run,
            accelerator = self.hotkey
        )

        # “上一页”按钮
        prev_btn = self.context.add_tool(
            ttk.Button,
            kwargs = {
                "text": "←",
                "command": self.run,
                "width": 3,
            }
        )

        # 将这个按钮组件添加到 context 中，以便其他插件访问
        self.context.get_prev_button = lambda: prev_btn


    @override
    def run(self) -> None:
        """
        执行上一页操作。
        """
        current_tab = self.context.get_current_tab()
        if current_tab is None:
            return

        # 切换到上一页
        if current_tab.page_no > 0:
            current_tab.page_no -= 1
            current_tab.show_page()
            self.context.update_page_number()
            self.context.update_page_turning_button()
        else:
            print("已经是第一页")


    @override
    def unloaded(self) -> None:
        pass

``````



[PageDown.cpython-313.pyc](.\plugins\Tab\PageTurning\__pycache__\PageDown.cpython-313.pyc) : 


[PageNo.cpython-313.pyc](.\plugins\Tab\PageTurning\__pycache__\PageNo.cpython-313.pyc) : 


[PageUp.cpython-313.pyc](.\plugins\Tab\PageTurning\__pycache__\PageUp.cpython-313.pyc) : 


[ScrollUp.py](.\plugins\Tab\Scroll\ScrollUp.py) : 
``````python
"""
向上滚动。
"""

from tkinter import ttk
from typing import override

from glueous_plugin import Plugin


class ScrollUpPlugin(Plugin):
    """
    向上滚动插件：允许用户通过快捷键或菜单项向上滚动页面。
    """

    # 插件信息
    name = "ScrollUpPlugin"
    description = "向上滚动页面，快捷键: Up"

    # 快捷键设置
    hotkeys = ["<Up>"]


    @override
    def loaded(self) -> None:
        """
        注册菜单项、快捷键。
        """
        # 注册菜单项、快捷键
        self.context.add_menu_command(
            path = ["前往"],
            label = "向上滚动",
            command = self.run,
            accelerator = self.hotkey
        )


    @override
    def run(self) -> None:
        """
        执行向上滚动操作。
        """
        current_tab = self.context.get_current_tab()
        if current_tab is None:
            return

        # 向上滚动画布
        current_tab.canvas.yview_scroll(-1, "units")


    @override
    def unloaded(self) -> None:
        pass

``````



[ScrollUp.cpython-313.pyc](.\plugins\Tab\Scroll\__pycache__\ScrollUp.cpython-313.pyc) : 


[Tab.py](.\plugins\Tab\Tab.py) : 
``````python
from __future__ import annotations

import tkinter as tk
from tkinter import filedialog, messagebox, ttk, Menu
import os
from typing import Any, Callable, Dict, List, TYPE_CHECKING, override
from types import MethodType

from PIL import Image, ImageTk
import fitz  # PyMuPDF

from plugins.Tab.FileState import FileState

from glueous import ReaderAccess
from glueous_plugin import Plugin



class Tab:
    """
    Tab 类，单个文件的标签页容器，管理单电子书文件的显示和状态。
    """

    def __init__(self, context: ReaderAccess, file_path: str = None):
        self.context = context

        # 与父容器建立关联
        self.notebook = self.context.get_notebook() # 父标签页容器
        self.frame = ttk.Frame(self.notebook)  # 标签页内容框架
        self.notebook.add(self.frame)          # 将frame添加到Notebook

        # 从应用数据中搜索这本书的数据
        file_states = self.context.get_data().setdefault("file_states", [])
        for file_state in file_states:
            # 查找路径相同的
            if file_state["file_path"] == file_path:
                self.state = file_state
                break
        else:
            # 找遍了也没找到
            self.state = FileState(file_path).to_json()
            file_states.insert(0, self.state)

        # 创建标签页内的UI组件
        self.create_widgets()

        # 打开文件
        self.doc = None  # PyMuPDF文档对象
        self.total_pages = 0
        self.open()


    def __getattr__(self, attr_name: str) -> Any:
        """
        返回此对象的属性。如果在此对象本身上找不到，则再在 self.state 里找。
        """
        state = self.__dict__.get('state')
        if state is not None and attr_name in state:
            return state[attr_name]
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{attr_name}'")


    def __setattr__(self, attr_name: str, value: Any) -> None:
        """
        设置此对象的属性。如果 attr_name 在 __annotations__ 中，则设置到 self.state 中。
        """
        # 特殊处理 state 属性本身的设置
        if attr_name == 'state':
            super().__setattr__(attr_name, value)
            return

        # 获取类的 annotations（即类型提示）
        annotations = getattr(self.__class__, '__annotations__', {})

        # 安全地获取 state
        state = self.__dict__.get('state')

        # 如果 attr_name 是类中声明的字段，或 state 还未初始化，或属性不在 state 中
        # 则直接设置到对象上
        if (attr_name in annotations) or (state is None) or (attr_name not in state):
            super().__setattr__(attr_name, value)
        else:
            # 设置到 state 中
            state[attr_name] = value


    def create_widgets(self):
        """
        创建标签页内的显示组件（画布、滚动条等）。
        """
        # 显示区域（带滚动条）
        self.display_frame = ttk.Frame(self.frame)

        self.vscroll = ttk.Scrollbar(self.display_frame, orient=tk.VERTICAL)
        self.vscroll.pack(side=tk.RIGHT, fill=tk.Y)

        self.hscroll = ttk.Scrollbar(self.display_frame, orient=tk.HORIZONTAL)
        self.hscroll.pack(side=tk.BOTTOM, fill=tk.X)

        self.canvas = tk.Canvas(
            self.display_frame,
            yscrollcommand=self.vscroll.set,
            xscrollcommand=self.hscroll.set,
            bg="white",
            highlightthickness=0
        )
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.vscroll.config(command=self.canvas.yview)
        self.hscroll.config(command=self.canvas.xview)

        self.display_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)


    def open(self) -> bool:
        """
        打开文件并初始化。

        返回是否打开成功。
        """
        try:
            # 关闭已打开的文档
            if self.doc:
                self.doc.close()

            self.doc = fitz.open(self.file_path)
            self.total_pages = len(self.doc)

            # 刷新显示
            self.show_page()

            # 更新标签页标题（显示文件名）
            tab_title = os.path.basename(self.file_path)
            self.notebook.tab(self.frame, text = tab_title)


            # 计数打开次数
            self.state["open_count"] += 1
            return True
        except Exception as e:
            messagebox.showerror("错误", f"打开失败: {str(e)}")
            self.reset_tab()
            return False


    def show_page(self):
        """
        渲染当前页。
        """
        if not self.doc or not (0 <= self.page_no < self.total_pages):
            return

        # 清空画布和缓存
        self.canvas.delete("all")

        # 渲染页面图像
        page = self.doc[self.page_no]
        mat = fitz.Matrix(self.zoom / 100, self.zoom / 100)
        pix = page.get_pixmap(matrix=mat)
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
        self.tk_img = ImageTk.PhotoImage(image=img)
        ####
        self.canvas.create_image(self.scroll_pos[0], self.scroll_pos[1], anchor=tk.NW, image=self.tk_img)
        self.canvas.config(scrollregion=(0, 0, pix.width, pix.height))


    def update_zoom(self, zoom_level):
        """更新缩放比例"""
        self.zoom = zoom_level
        self.show_page()


    def reset_tab(self):
        """重置标签页状态"""
        if self.doc:
            self.doc.close()
        self.state = None
        self.doc = None
        self.total_pages = 0
        self.canvas.delete("all")
        # 仅在frame被管理时修改标签标题
        try:
            self.notebook.tab(self.frame, text="空标签页")
        except tk.TclError:
            # 若frame已被移除，忽略错误
            pass



class TabPlugin(Plugin):
    """
    标签页插件：提供对标签页的管理接口。
    """

    # 插件信息
    name = "TabPlugin"
    description = "提供对标签页的管理接口"


    @staticmethod
    def create_tab(access: ReaderAccess, file_path: str | None = None) -> Tab:
        """
        创建新标签页
        """
        new_tab = Tab(access, file_path)

        # 激活新标签页
        access._reader.notebook.select(new_tab.frame)

        # 添加到标签页列表
        access._reader.tabs.append(new_tab)


    @staticmethod
    def get_current_tab(access: ReaderAccess) -> Tab | None:
        """
        获取当前激活的标签页实例。
        """
        reader = access._reader

        if not reader.tabs:
            return None

        # 获取当前选中标签页的路径字符串
        current_frame_path = reader.notebook.select()
        if not current_frame_path:
            return None

        # 将路径字符串转换为窗口对象
        try:
            current_frame = reader.root.nametowidget(current_frame_path)
        except KeyError:
            return None

        # 从标签页列表中找到匹配的 Tab
        for tab in reader.tabs:
            if tab.frame == current_frame:
                return tab
        return None


    @staticmethod
    def close_tab(access: ReaderAccess, tab: Tab):
        """
        关闭一个标签页，返回是否成功关闭。
        """
        reader = access._reader

        if tab in reader.tabs:
            reader.tabs.remove(tab)

        tab.reset_tab()
        reader.notebook.forget(tab.frame)


    @override
    def loaded(self) -> None:
        """
        在插件被加载时运行。
        """
        reader = self.context._reader
        reader.tabs: List[Tab] = []

        # 添加操作标签的接口，方便其他插件调用
        self.context.create_tab      = MethodType(self.create_tab     , self.context)
        self.context.get_current_tab = MethodType(self.get_current_tab, self.context)
        self.context.close_tab       = MethodType(self.close_tab      , self.context)
        self.context.tabs: List[Tab] = reader.tabs
        self.context.Tab : type      = Tab


    @override
    def run(self) -> None:
        pass


    @override
    def unloaded(self) -> None:
        pass

``````



[ZoomIn.py](.\plugins\Tab\Zoom\ZoomIn.py) : 
``````python
"""
此插件实现对页面的放大。
"""

from tkinter import ttk
from typing import override

from glueous_plugin import Plugin


class ZoomInPlugin(Plugin):
    """
    放大插件：允许用户通过快捷键或菜单项放大当前页面。
    """

    # 插件信息
    name = "ZoomInPlugin"
    description = "放大当前页面，快捷键: Ctrl++"

    # 快捷键设置
    hotkeys = ["<Control-plus>"]


    @override
    def loaded(self) -> None:
        """
        注册菜单项、快捷键、“放大”按钮。
        """
        # 注册菜单项、快捷键
        self.context.add_menu_command(
            path = ["缩放"],
            label = "放大",
            command = self.run,
            accelerator = self.hotkey
        )

        # “放大”按钮
        zoom_in_btn = self.context.add_tool(
        	ttk.Button,
        	kwargs = {
        		"text": "+",
        		"command": self.run,
        		"width": 2,
        	}
        )

        # 将这个按钮组件添加到 context 中，以便其他插件访问
        self.context.get_zoom_in_button = lambda: zoom_in_btn


    @override
    def run(self) -> None:
        """
        执行放大操作。
        """
        current_tab = self.context.get_current_tab()
        if current_tab is None:
            return

        # 获取当前缩放级别
        current_zoom = current_tab.zoom

        # 获取预设的缩放等级列表
        zoom_levels = self.context.get_setting("zoom_levels", [100])

        # 找到下一个更大的缩放级别
        new_zoom = zoom_levels[-1]  # 默认最大级别
        for level in zoom_levels:
            if level > current_zoom:
                new_zoom = level
                break

        # 更新缩放级别
        current_tab.update_zoom(new_zoom)


    @override
    def unloaded(self) -> None:
        pass

``````



[ZoomOut.py](.\plugins\Tab\Zoom\ZoomOut.py) : 
``````python
"""
此插件实现对页面的缩小。
"""

from tkinter import ttk
from typing import override

from glueous_plugin import Plugin


class ZoomOutPlugin(Plugin):
    """
    缩小插件：允许用户通过快捷键或菜单项缩小当前页面。
    """

    # 插件信息
    name = "ZoomOutPlugin"
    description = "缩小当前页面，快捷键: Ctrl+-"

    # 快捷键设置
    hotkeys = ["<Control-minus>"]


    @override
    def loaded(self) -> None:
        """
        注册菜单项、快捷键、“缩小”按钮。
        """
        # 注册菜单项、快捷键
        self.context.add_menu_command(
            path = ["缩放"],
            label = "缩小",
            command = self.run,
            accelerator = self.hotkey
        )

        # “缩小”按钮
        zoom_out_btn = self.context.add_tool(
            ttk.Button,
            kwargs = {
                "text": "-",
                "command": self.run,
                "width": 2,
            }
        )

        # 将这个按钮组件添加到 context 中，以便其他插件访问
        self.context.get_zoom_out_button = lambda: zoom_out_btn


    @override
    def run(self) -> None:
        """
        执行缩小操作。
        """
        current_tab = self.context.get_current_tab()
        if current_tab is None:
            return

        # 获取当前缩放级别
        current_zoom = current_tab.zoom

        # 获取预设的缩放等级列表
        zoom_levels = self.context.get_setting("zoom_levels", [100])

        # 找到下一个更小的缩放级别
        new_zoom = zoom_levels[0]  # 默认最小级别
        for level in reversed(zoom_levels):
            if level < current_zoom:
                new_zoom = level
                break

        # 更新缩放级别
        current_tab.update_zoom(new_zoom)


    @override
    def unloaded(self) -> None:
        pass

``````



[ZoomIn.cpython-313.pyc](.\plugins\Tab\Zoom\__pycache__\ZoomIn.cpython-313.pyc) : 


[ZoomOut.cpython-313.pyc](.\plugins\Tab\Zoom\__pycache__\ZoomOut.cpython-313.pyc) : 


[__init__.py](.\plugins\Tab\__init__.py) : 
``````python

``````



[FileState.cpython-313.pyc](.\plugins\Tab\__pycache__\FileState.cpython-313.pyc) : 


[Tab.cpython-313.pyc](.\plugins\Tab\__pycache__\Tab.cpython-313.pyc) : 


[__init__.cpython-313.pyc](.\plugins\Tab\__pycache__\__init__.cpython-313.pyc) : 


[_copy_plugin](.\plugins\_copy_plugin) : 


[__init__.py](.\plugins\__init__.py) : 
``````python
"""
A folder used to store plugins.
"""
from typing import List

# 插件加载顺序
plugin_loading_order: List[str] = [
    "TabPlugin",
    "OpenPlugin",
    "ClosePlugin",
    "PageUpPlugin",
    "PageNoPlugin",
    "PageDownPlugin",
    "ZoomOutPlugin",
    "ZoomInPlugin",
]

``````



[copy_plugin.cpython-313.pyc](.\plugins\__pycache__\copy_plugin.cpython-313.pyc) : 


[plugin_base.cpython-313.pyc](.\plugins\__pycache__\plugin_base.cpython-313.pyc) : 


[_plugin_base.cpython-313.pyc](.\plugins\__pycache__\_plugin_base.cpython-313.pyc) : 


[__init__.cpython-313.pyc](.\plugins\__pycache__\__init__.cpython-313.pyc) : 


[project.md](.\project.md) : 


[README.md](.\README.md) : 


[requirements.txt](.\requirements.txt) : 
``````
pymupdf

``````



[pdf_reader.cpython-313.pyc](.\__pycache__\pdf_reader.cpython-313.pyc) : 


[整合项目03.py](.\整合项目03.py) : 
``````python
import os

def language(suffix:str):
    mapping = {
        ".dart":"dart",
        ".cpp":"cpp",
        ".h":"h",
        ".sv":"systemverilog",
        ".xdc":"tcl",
        ".txt":"",
        ".lua":"lua",
        ".py":"python"
    }
    if suffix in mapping:
        return mapping[suffix]
    else:
        return False

def read(path, encoding = "utf-8"):
    print(path)
    with open(path, mode = 'r', encoding = encoding) as file:
        return ''.join(file.readlines())

def append(tarpath, path, encoding = "utf-8"):
    if os.path.isfile(path):
        lang = language(os.path.splitext(path)[1])
        with open(tarpath, mode = 'a', encoding = "utf-8") as file:
            file.write("[%s](%s) : \n"%(os.path.basename(path), path))
            if not (lang is False):
                file.write("``````%s\n"%(lang))
                file.write(read(path, encoding))
                file.write("\n``````\n\n")
            file.write("\n\n")

    elif os.path.isdir(path):
        for filename in os.listdir(path):
            append(tarpath = tarpath, path = os.path.join(path, filename), encoding = encoding)

tarpath = r"project.md"
srcpath = r"."
with open(tarpath, mode = "w", encoding = "utf-8"):
    pass

append(tarpath = tarpath, path = srcpath)

``````



